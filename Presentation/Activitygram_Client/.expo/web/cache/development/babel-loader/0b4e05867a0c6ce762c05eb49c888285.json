{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport React from \"react\";\nexport var isNumeric = function isNumeric(num) {\n  return !isNaN(parseFloat(num)) && isFinite(num);\n};\nexport var processBlock = function processBlock(_ref) {\n  var containerHeight = _ref.containerHeight,\n      scrollTop = _ref.scrollTop,\n      _ref$batchSizeThresho = _ref.batchSizeThreshold,\n      batchSizeThreshold = _ref$batchSizeThresho === void 0 ? 1 : _ref$batchSizeThresho;\n\n  if (containerHeight === 0) {\n    return {\n      batchSize: 0,\n      blockStart: 0,\n      blockEnd: 0\n    };\n  }\n\n  var batchSize = Math.ceil(containerHeight * Math.max(0.5, batchSizeThreshold));\n  var blockNumber = Math.ceil(scrollTop / batchSize);\n  var blockStart = batchSize * blockNumber;\n  var blockEnd = blockStart + batchSize;\n  return {\n    batchSize: batchSize,\n    blockStart: blockStart,\n    blockEnd: blockEnd\n  };\n};\nexport var autobind = function autobind() {\n  var self = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var exclude = [\"componentWillMount\", /UNSAFE_.*/, \"render\", \"getSnapshotBeforeUpdate\", \"componentDidMount\", \"componentWillReceiveProps\", \"shouldComponentUpdate\", \"componentWillUpdate\", \"componentDidUpdate\", \"componentWillUnmount\", \"componentDidCatch\", \"setState\", \"forceUpdate\"];\n\n  var filter = function filter(key) {\n    var match = function match(pattern) {\n      return typeof pattern === \"string\" ? key === pattern : pattern.test(key);\n    };\n\n    if (exclude) {\n      return !exclude.some(match);\n    }\n\n    return true;\n  };\n\n  var getAllProperties = function getAllProperties(object) {\n    var properties = new Set();\n\n    do {\n      for (var _iterator = _createForOfIteratorHelperLoose(Object.getOwnPropertyNames(object).concat(Object.getOwnPropertySymbols(object))), _step; !(_step = _iterator()).done;) {\n        var key = _step.value;\n        properties.add([object, key]);\n      }\n    } while ((object = Object.getPrototypeOf(object)) && object !== Object.prototype);\n\n    return properties;\n  };\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(getAllProperties(self.constructor.prototype)), _step2; !(_step2 = _iterator2()).done;) {\n    var _ref2 = _step2.value;\n\n    var _ref3 = _slicedToArray(_ref2, 2);\n\n    var object = _ref3[0];\n    var key = _ref3[1];\n\n    if (key === \"constructor\" || !filter(key)) {\n      continue;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(object, key);\n\n    if (descriptor && typeof descriptor.value === \"function\") {\n      self[key] = self[key].bind(self);\n    }\n  }\n\n  return self;\n};\nexport var mergeViewStyle = function mergeViewStyle(style) {\n  var defaultStyle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var mergedStyle = style;\n\n  if (mergedStyle == null) {\n    mergedStyle = defaultStyle;\n  } else if (Array.isArray(style) && Array.isArray(defaultStyle)) {\n    var mergedDefaultStyle = _toConsumableArray(defaultStyle);\n\n    mergedDefaultStyle.concat(style);\n    mergedStyle = mergedDefaultStyle;\n  } else if (Array.isArray(defaultStyle)) {\n    var _mergedDefaultStyle = _toConsumableArray(defaultStyle);\n\n    _mergedDefaultStyle.push(style);\n\n    mergedStyle = _mergedDefaultStyle;\n  } else if (Array.isArray(style)) {\n    mergedStyle = _toConsumableArray(style);\n    mergedStyle.unshift(defaultStyle);\n  } else {\n    mergedStyle = [defaultStyle, style];\n  }\n\n  return mergedStyle;\n};\nexport var createElement = function createElement(Component) {\n  return Component != null ? React.isValidElement(Component) ? Component : React.createElement(Component, null) : null;\n};","map":{"version":3,"sources":["utils.js"],"names":["isNumeric","num","batchSizeThreshold","containerHeight","batchSize","blockEnd","blockNumber","Math","scrollTop","blockStart","autobind","key","properties","descriptor","self","mergedStyle","Array","mergedDefaultStyle","Component"],"mappings":"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","sourcesContent":["import React from \"react\";\n\n/**\n * Is numeric.\n * @param {any} num\n * @returns {boolean}\n */\nexport const isNumeric = (num) => {\n  return !isNaN(parseFloat(num)) && isFinite(num);\n};\n\n/**\n * Process block.\n * @param {number} containerHeight\n * @param {number} scrollTop\n * @param {number|null|undefined} batchSizeThreshold\n * @returns {{blockStart: number, batchSize: number, blockEnd: number}}\n */\nexport const processBlock = ({\n  containerHeight,\n  scrollTop,\n  batchSizeThreshold = 1,\n}) => {\n  if (containerHeight === 0) {\n    return {\n      batchSize: 0,\n      blockStart: 0,\n      blockEnd: 0,\n    };\n  }\n  const batchSize = Math.ceil(\n    containerHeight * Math.max(0.5, batchSizeThreshold),\n  );\n  const blockNumber = Math.ceil(scrollTop / batchSize);\n  const blockStart = batchSize * blockNumber;\n  const blockEnd = blockStart + batchSize;\n  return { batchSize, blockStart, blockEnd };\n};\n\n/**\n * Autobind context to class methods.\n * @param {object} self\n * @returns {{}}\n */\nexport const autobind = (self = {}) => {\n  const exclude = [\n    \"componentWillMount\",\n    /UNSAFE_.*/,\n    \"render\",\n    \"getSnapshotBeforeUpdate\",\n    \"componentDidMount\",\n    \"componentWillReceiveProps\",\n    \"shouldComponentUpdate\",\n    \"componentWillUpdate\",\n    \"componentDidUpdate\",\n    \"componentWillUnmount\",\n    \"componentDidCatch\",\n    \"setState\",\n    \"forceUpdate\",\n  ];\n\n  const filter = (key) => {\n    const match = (pattern) =>\n      typeof pattern === \"string\" ? key === pattern : pattern.test(key);\n    if (exclude) {\n      return !exclude.some(match);\n    }\n    return true;\n  };\n\n  const getAllProperties = (object) => {\n    const properties = new Set();\n    do {\n      for (const key of Object.getOwnPropertyNames(object).concat(\n        Object.getOwnPropertySymbols(object),\n      )) {\n        properties.add([object, key]);\n      }\n    } while (\n      (object = Object.getPrototypeOf(object)) &&\n      object !== Object.prototype\n    );\n    return properties;\n  };\n\n  for (const [object, key] of getAllProperties(self.constructor.prototype)) {\n    if (key === \"constructor\" || !filter(key)) {\n      continue;\n    }\n    const descriptor = Object.getOwnPropertyDescriptor(object, key);\n    if (descriptor && typeof descriptor.value === \"function\") {\n      self[key] = self[key].bind(self);\n    }\n  }\n  return self;\n};\n\n/**\n * Merge styles\n * @param {array|object|null|undefined} style\n * @param {array|object} defaultStyle\n * @returns {Object}\n */\nexport const mergeViewStyle = (style, defaultStyle = {}) => {\n  let mergedStyle = style;\n  if (mergedStyle == null) {\n    mergedStyle = defaultStyle;\n  } else if (Array.isArray(style) && Array.isArray(defaultStyle)) {\n    const mergedDefaultStyle = [...defaultStyle];\n    mergedDefaultStyle.concat(style);\n    mergedStyle = mergedDefaultStyle;\n  } else if (Array.isArray(defaultStyle)) {\n    const mergedDefaultStyle = [...defaultStyle];\n    mergedDefaultStyle.push(style);\n    mergedStyle = mergedDefaultStyle;\n  } else if (Array.isArray(style)) {\n    mergedStyle = [...style];\n    mergedStyle.unshift(defaultStyle);\n  } else {\n    mergedStyle = [defaultStyle, style];\n  }\n  return mergedStyle;\n};\n\n/**\n * Get element from component.\n * @param {React.node} Component\n * @returns {JSX.Element|[]|*}\n */\nexport const createElement = (Component) => {\n  return Component != null ? (\n    React.isValidElement(Component) ? (\n      Component\n    ) : (\n      <Component />\n    )\n  ) : null;\n};\n"]},"metadata":{},"sourceType":"module"}